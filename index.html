<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Solitaire (Klondike)</title>
    <!-- Tailwind (CDN for demo) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React 18 UMD -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- In-browser JSX compiler (demo only) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body class="min-h-screen bg-slate-900">
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // ----- Helpers -----
      const SUITS = ["♠", "♥", "♦", "♣"]; // Spades, Hearts, Diamonds, Clubs
      const RANKS = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];

      function makeDeck() {
        const deck = [];
        let id = 0;
        for (const suit of SUITS) {
          for (let i = 0; i < RANKS.length; i++) {
            const rank = RANKS[i];
            const color = suit === "♥" || suit === "♦" ? "red" : "black";
            deck.push({ id: id++, suit, rank, value: i + 1, color, faceUp: false });
          }
        }
        return deck;
      }

      function shuffle(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      function canPlaceOnTableau(srcCard, dstCard) {
        if (!dstCard) return srcCard.rank === "K"; // empty accepts King
        return dstCard.value === srcCard.value + 1 && dstCard.color !== srcCard.color;
      }

      function canPlaceOnFoundation(card, foundationTop) {
        if (!foundationTop) return card.rank === "A";
        return foundationTop.suit === card.suit && card.value === foundationTop.value + 1;
      }

      function Card({ card, onClick, selected }) {
        const isFaceUp = !!(card && card.faceUp);
        const rank = (card && card.rank) || "";
        const suit = (card && card.suit) || "";
        const color = (card && card.color) || "black";

        const face = (
          <div
            className={`relative w-[80px] h-[112px] rounded-2xl shadow-md border border-white/30 
            ${selected ? "ring-4 ring-yellow-400" : ""} 
            bg-white/95 backdrop-blur text-gray-900 flex items-center justify-center`}
            onClick={onClick}
          >
            <div className="absolute top-1.5 left-2 text-xs opacity-80 select-none" style={{ color: color === "red" ? "#dc2626" : "#111827" }}>
              <div>{rank}</div>
              <div>{suit}</div>
            </div>
            <div className="text-2xl font-semibold select-none" style={{ color: color === "red" ? "#dc2626" : "#111827" }}>
              {rank}{suit}
            </div>
          </div>
        );

        const back = (
          <div className={`w-[80px] h-[112px] rounded-2xl shadow-md border border-white/30 bg-gradient-to-br from-sky-600 to-indigo-700 pattern select-none ${selected ? "ring-4 ring-yellow-400" : ""}`} onClick={onClick}>
            <div className="w-full h-full rounded-2xl border-2 border-white/40" />
          </div>
        );

        return isFaceUp ? face : back;
      }

      function Solitaire() {
        const [tableau, setTableau] = useState([[], [], [], [], [], [], []]); // 7 piles
        const [foundations, setFoundations] = useState([[], [], [], []]); // per suit order: ♠ ♥ ♦ ♣
        const [stock, setStock] = useState([]); // face-down deck
        const [waste, setWaste] = useState([]); // face-up discard
        const [selected, setSelected] = useState(null); // { from: 'tableau'|'waste', pileIndex, cardIndex }
        const [score, setScore] = useState(0);
        const [moves, setMoves] = useState(0);
        const [message, setMessage] = useState("");
        const [highlightStock, setHighlightStock] = useState(false); // transient highlight for Stock
        const [showTips, setShowTips] = useState(false);
        const lastClickRef = useRef(0);

        useEffect(() => {
          startNewGame();
        }, []);

        function startNewGame() {
          const deck = shuffle(makeDeck());
          const t = [[], [], [], [], [], [], []];
          let idx = 0;
          for (let p = 0; p < 7; p++) {
            for (let c = 0; c <= p; c++) {
              const card = deck[idx++];
              card.faceUp = c === p; // top card face-up
              t[p].push(card);
            }
          }
          const remaining = deck.slice(idx);
          setTableau(t);
          setFoundations([[], [], [], []]);
          setStock(remaining);
          setWaste([]);
          setSelected(null);
          setScore(0);
          setMoves(0);
          setMessage("");
        }

        function dealFromStock() {
          setMessage("");
          setHighlightStock(true);
          setTimeout(() => setHighlightStock(false), 150);
          if (stock.length === 0) {
            if (waste.length === 0) return;
            const newStock = waste.slice().reverse().map(c => ({ ...c, faceUp: false }));
            setStock(newStock);
            setWaste([]);
            setMoves(m => m + 1);
            return;
          }
          const top = stock[stock.length - 1];
          const newStock = stock.slice(0, -1);
          setStock(newStock);
          setWaste(w => [...w, { ...top, faceUp: true }]);
          setMoves(m => m + 1);
        }

        function onCardClick(loc) {
          setMessage("");

          const now = Date.now();
          if (now - lastClickRef.current < 300) {
            tryAutoToFoundation(loc);
          }
          lastClickRef.current = now;

          if (loc.from === "foundation") return;

          if (!selected) {
            if (loc.from === "waste") {
              const card = waste[waste.length - 1];
              if (!card) return;
              setSelected({ from: "waste", pileIndex: 0, cardIndex: waste.length - 1 });
            } else if (loc.from === "tableau") {
              const pile = tableau[loc.pileIndex];
              const card = pile[loc.cardIndex];
              if (!card || !card.faceUp) return;
              setSelected(loc);
            }
            return;
          }

          if (selected) {
            if (loc.from === "tableau") {
              dropOnTableau(loc.pileIndex);
            }
          }
        }

        function dropOnTableau(dstIndex) {
          if (!selected) return;
          const t = tableau.map(p => p.slice());

          let moving = [];
          if (selected.from === "waste") {
            const w = waste.slice();
            if (w.length === 0) return;
            moving = [w[w.length - 1]];
            const dstTop = t[dstIndex][t[dstIndex].length - 1];
            if (!canPlaceOnTableau(moving[0], dstTop)) return setMessage("Illegal move");
            w.pop();
            setWaste(w);
          } else {
            const srcPile = t[selected.pileIndex];
            moving = srcPile.slice(selected.cardIndex);
            const dstTop = t[dstIndex][t[dstIndex].length - 1];
            if (!moving[0].faceUp) return setMessage("Card is face down");
            if (!canPlaceOnTableau(moving[0], dstTop)) return setMessage("Illegal move");
            t[selected.pileIndex] = srcPile.slice(0, selected.cardIndex);
            const np = t[selected.pileIndex];
            if (np.length && !np[np.length - 1].faceUp) {
              np[np.length - 1].faceUp = true;
              setScore(s => s + 5); // flip bonus
            }
          }

          t[dstIndex] = t[dstIndex].concat(moving);
          setTableau(t);
          setSelected(null);
          setMoves(m => m + 1);
          setScore(s => s + 5);
          checkWin(t, foundations);
        }

        function tryAutoToFoundation(loc) {
          let card = null;
          let from = null;
          let srcIndex = -1;

          if (loc.from === "waste") {
            if (waste.length === 0) return;
            card = waste[waste.length - 1];
            from = "waste";
          } else if (loc.from === "tableau") {
            const pile = tableau[loc.pileIndex];
            if (!pile.length) return;
            card = pile[pile.length - 1];
            if (!card.faceUp) return;
            from = "tableau";
            srcIndex = loc.pileIndex;
          } else return;

          const f = foundations.map(x => x.slice());
          const suitIndex = SUITS.indexOf(card.suit);
          const top = f[suitIndex][f[suitIndex].length - 1];
          if (!canPlaceOnFoundation(card, top)) return;

          if (from === "waste") {
            const w = waste.slice(0, -1);
            setWaste(w);
          } else {
            const t = tableau.map(p => p.slice());
            t[srcIndex].pop();
            if (t[srcIndex].length && !t[srcIndex][t[srcIndex].length - 1].faceUp) {
              t[srcIndex][t[srcIndex].length - 1].faceUp = true;
              setScore(s => s + 5);
            }
            setTableau(t);
            checkWin(t, f);
          }

          f[suitIndex].push(card);
          setFoundations(f);
          setMoves(m => m + 1);
          setScore(s => s + 10);
          setSelected(null);
          checkWin(tableau, f);
        }

        function onFoundationClick(fIndex) {
          setMessage("");
          const f = foundations.map(x => x.slice());
          const top = f[fIndex][f[fIndex].length - 1];

          if (!selected) return;
          if (selected.from === "waste") {
            const w = waste.slice();
            const card = w[w.length - 1];
            if (!card) return;
            if (!canPlaceOnFoundation(card, top)) return setMessage("Can't move to foundation");
            w.pop();
            f[fIndex].push(card);
            setWaste(w);
          } else {
            const t = tableau.map(p => p.slice());
            const pile = t[selected.pileIndex];
            const card = pile[pile.length - 1];
            if (!card || !card.faceUp) return;
            if (!canPlaceOnFoundation(card, top)) return setMessage("Can't move to foundation");
            pile.pop();
            if (pile.length && !pile[pile.length - 1].faceUp) {
              pile[pile.length - 1].faceUp = true;
              setScore(s => s + 5);
            }
            setTableau(t);
          }

          setFoundations(f);
          setScore(s => s + 10);
          setMoves(m => m + 1);
          setSelected(null);
          checkWin(tableau, f);
        }

        function onTableauBackgroundClick(pileIndex) {
          if (selected) {
            if (tableau[pileIndex].length === 0) {
              dropOnTableau(pileIndex);
            } else {
              setSelected(null);
            }
          }
        }

        function checkWin(t = tableau, f = foundations) {
          const totalFound = f.reduce((acc, p) => acc + p.length, 0);
          if (totalFound === 52) {
            setMessage("You win! All cards to foundations.");
          }
        }

        function renderTableauPile(pile, pIndex) {
          const offset = 24;
          return (
            <div key={pIndex} className="relative w-[80px] min-h-[112px]" onClick={() => onTableauBackgroundClick(pIndex)}>
              <div className="absolute inset-0 rounded-2xl border-2 border-dashed border-white/25" />
              {pile.map((card, idx) => (
                <div key={card.id} className="absolute" style={{ top: idx * offset }}>
                  <Card
                    card={card}
                    selected={!!(selected && selected.from === "tableau" && selected.pileIndex === pIndex && selected.cardIndex === idx)}
                    onClick={() => onCardClick({ from: "tableau", pileIndex: pIndex, cardIndex: idx })}
                  />
                </div>
              ))}
            </div>
          );
        }

        function renderFoundation(index) {
          const pile = foundations[index];
          const offset = 2;
          return (
            <div key={index} className="relative w-[80px] h-[112px]" onClick={() => onFoundationClick(index)}>
              <div className="absolute inset-0 rounded-2xl border-2 border-dashed border-emerald-300/50" />
              {pile.map((card, i) => (
                <div key={card.id} className="absolute" style={{ top: Math.min(i * offset, 12), left: Math.min(i * offset, 12), zIndex: i }}>
                  <Card card={card} />
                </div>
              ))}
              {pile.length === 0 && (
                <div className="absolute inset-0 flex items-center justify-center text-2xl opacity-80 select-none">{SUITS[index]}</div>
              )}
            </div>
          );
        }

        const wasteTop = waste[waste.length - 1];

        return (
          <div className="min-h-screen w-full bg-gradient-to-br from-emerald-900 via-slate-900 to-indigo-950 text-white p-4 pb-24 md:pb-28">
            <div className="max-w-6xl mx-auto">
              <header className="flex items-center justify-between mb-3">
                <h1 className="text-xl md:text-2xl font-semibold">Solitaire (Klondike)</h1>
                <div className="flex items-center gap-3 text-sm md:text-base">
                  <div className="px-3 py-1 rounded-xl bg-white/10">Score: <span className="font-semibold">{score}</span></div>
                  <div className="px-3 py-1 rounded-xl bg-white/10">Moves: <span className="font-semibold">{moves}</span></div>
                  <button className="px-3 py-1.5 rounded-xl bg-white/10 hover:bg-white/15 border border-white/20" onClick={() => setShowTips(v => !v)}>{showTips ? "Hide Tips" : "Show Tips"}</button>
                  <button className="px-3 py-1.5 rounded-xl bg-yellow-400 text-black font-semibold shadow hover:brightness-95" onClick={startNewGame}>New Game</button>
                </div>
              </header>

              {message && (
                <div className="fixed left-1/2 -translate-x-1/2 z-50 max-w-[90vw] px-4 py-2 rounded-xl bg-amber-500/20 border border-amber-400/40 text-amber-200 shadow-lg backdrop-blur pointer-events-none" style={{ bottom: "calc(env(safe-area-inset-bottom, 0px) + 40px)" }}>
                  {message}
                </div>
              )}

              {/* Top row: Stock, Waste, Foundations */}
              <div className="grid grid-cols-3 md:grid-cols-4 gap-4 mb-6">
                {/* Left: Stock + Waste */}
                <div className="flex items-start gap-4 col-span-2 md:col-span-1">
                  {/* Stock */}
                  <div className={`relative w-[80px] h-[112px] ${highlightStock ? "ring-4 ring-yellow-400 rounded-2xl" : ""}`} onClick={dealFromStock}>
                    <div className="absolute inset-0 rounded-2xl border-2 border-dashed border-white/25" />
                    {stock.length > 0 && (
                      <div className="absolute inset-0">
                        {/* top of stock (face-down) */}
                        <Card card={{ faceUp: false }} selected={highlightStock} />
                      </div>
                    )}
                  </div>

                  {/* Waste */}
                  <div className="relative w-[80px] h-[112px]" onClick={() => onCardClick({ from: "waste" })}>
                    <div className="absolute inset-0 rounded-2xl border-2 border-dashed border-white/25" />
                    {wasteTop && (
                      <div className="absolute inset-0">
                        <Card card={wasteTop} selected={!!(selected && selected.from === "waste")} />
                      </div>
                    )}
                  </div>
                </div>

                {/* Right: Foundations */}
                <div className="col-span-1 md:col-span-3">
                  <div className="flex gap-4 justify-end">
                    {SUITS.map((_, i) => renderFoundation(i))}
                  </div>
                </div>
              </div>

              {/* Tableau */}
              <div className="grid grid-cols-7 gap-3 md:gap-4">
                {tableau.map((pile, idx) => renderTableauPile(pile, idx))}
              </div>

              {/* Tips overlay (toggleable) */}
              {showTips && (
                <div className="fixed left-1/2 -translate-x-1/2 bottom-2 z-40 text-sm opacity-90 bg-black/50 px-4 py-2 rounded-xl border border-white/20 backdrop-blur">
                  Tips: Click the stock to deal. Click a face-up card to select; click a destination pile to drop. Double‑click a top face‑up card to auto‑move to a foundation if legal. Empty tableau columns accept only a King (with its stack).
                </div>
              )}
            </div>

            {/* subtle tiling pattern */}
            <style>{`
              .pattern { background-image: radial-gradient(rgba(255,255,255,0.12) 2px, transparent 2px); background-size: 18px 18px; }
            `}</style>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(<Solitaire />);
    </script>
  </body>
</html>
